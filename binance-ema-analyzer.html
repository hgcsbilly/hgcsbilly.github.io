<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizador EMA de Binance - Personalizado</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            text-align: center;
            color: #333;
        }
        input, select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #startButton {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        #startButton:hover {
            background-color: #45a049;
        }
        #symbolsList, #alertsContainer, #upcomingCrossesContainer, #pastCrossesContainer {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            height: 100px;
            overflow-y: auto;
        }
        #chartContainer {
            margin-top: 20px;
            height: 400px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Analizador EMA de Binance - Personalizado</h1>
        <input type="text" id="symbolsInput" placeholder="Símbolos separados por coma (ej. BTCUSDT,ETHUSDT,BNBUSDT)">
        <input type="number" id="ema1Input" placeholder="EMA 1 (ej. 80)">
        <input type="number" id="ema2Input" placeholder="EMA 2 (ej. 240)">
        <select id="intervalSelect">
            <option value="1m">1 minuto</option>
            <option value="3m">3 minutos</option>
            <option value="5m">5 minutos</option>
            <option value="15m">15 minutos</option>
            <option value="30m">30 minutos</option>
            <option value="1h">1 hora</option>
            <option value="2h">2 horas</option>
            <option value="4h">4 horas</option>
            <option value="6h">6 horas</option>
            <option value="8h">8 horas</option>
            <option value="12h">12 horas</option>
            <option value="1d">1 día</option>
        </select>
        <button id="startButton">Iniciar Análisis</button>
        <h2>Símbolos Analizados</h2>
        <div id="symbolsList"></div>
        <select id="symbolSelect"></select>
        <div id="chartContainer"></div>
        <h2>Alertas en Tiempo Real</h2>
        <div id="alertsContainer"></div>
        <h2>Próximos Cruces de EMA</h2>
        <div id="upcomingCrossesContainer"></div>
        <h2>Últimos 10 Cruces de EMA</h2>
        <div id="pastCrossesContainer"></div>
    </div>

    <script>
        let ws = {};
        let symbolsData = {};
        let ema1Period, ema2Period, interval;
        let chart;
        let pastCrosses = [];

        document.getElementById('startButton').addEventListener('click', startAnalysis);
        document.getElementById('symbolSelect').addEventListener('change', updateChart);

        async function startAnalysis() {
            const symbolsInput = document.getElementById('symbolsInput').value;
            const symbols = symbolsInput.toUpperCase().split(',').map(s => s.trim());
            ema1Period = parseInt(document.getElementById('ema1Input').value);
            ema2Period = parseInt(document.getElementById('ema2Input').value);
            interval = document.getElementById('intervalSelect').value;

            if (!symbols.length || !ema1Period || !ema2Period) {
                alert('Por favor, completa todos los campos');
                return;
            }

            updateSymbolsList(symbols);
            updateSymbolSelect(symbols);

            for (let symbol of symbols) {
                await fetchHistoricalData(symbol);
                connectWebSocket(symbol);
            }
        }

        function updateSymbolsList(symbols) {
            const symbolsList = document.getElementById('symbolsList');
            symbolsList.textContent = symbols.join(', ');
        }

        function updateSymbolSelect(symbols) {
            const symbolSelect = document.getElementById('symbolSelect');
            symbolSelect.innerHTML = '';
            symbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                symbolSelect.appendChild(option);
            });
        }

        async function fetchHistoricalData(symbol) {
            const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=1000`);
            const data = await response.json();
            symbolsData[symbol] = {
                prices: data.map(d => parseFloat(d[4])),
                ema1: [],
                ema2: []
            };
            calculateEMAs(symbol);
        }

        function calculateEMAs(symbol) {
            const data = symbolsData[symbol];
            data.ema1 = calculateEMA(data.prices, ema1Period);
            data.ema2 = calculateEMA(data.prices, ema2Period);
        }

        function calculateEMA(prices, period) {
            let ema = [prices[0]];
            const multiplier = 2 / (period + 1);
            for (let i = 1; i < prices.length; i++) {
                ema.push((prices[i] - ema[i-1]) * multiplier + ema[i-1]);
            }
            return ema;
        }

        function connectWebSocket(symbol) {
            if (ws[symbol]) {
                ws[symbol].close();
            }

            ws[symbol] = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);

            ws[symbol].onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.e === 'kline') {
                    const price = parseFloat(data.k.c);
                    updateSymbolData(symbol, price);
                    checkEMACrossover(symbol);
                    if (symbol === document.getElementById('symbolSelect').value) {
                        updateChart();
                    }
                }
            };

            ws[symbol].onerror = (error) => {
                console.error(`WebSocket Error for ${symbol}:`, error);
                reconnectWebSocket(symbol);
            };

            ws[symbol].onclose = () => {
                console.log(`WebSocket Cerrado para ${symbol}`);
                reconnectWebSocket(symbol);
            };
        }

        function reconnectWebSocket(symbol) {
            setTimeout(() => {
                console.log(`Intentando reconectar WebSocket para ${symbol}...`);
                connectWebSocket(symbol);
            }, 5000);
        }

        function updateSymbolData(symbol, price) {
            const data = symbolsData[symbol];
            data.prices.push(price);
            data.ema1.push(calculateEMA(data.prices.slice(-ema1Period), ema1Period).pop());
            data.ema2.push(calculateEMA(data.prices.slice(-ema2Period), ema2Period).pop());

            if (data.prices.length > 1000) {
                data.prices.shift();
                data.ema1.shift();
                data.ema2.shift();
            }
        }

        function checkEMACrossover(symbol) {
            const data = symbolsData[symbol];
            if (data.ema1.length < 2 || data.ema2.length < 2) return;

            const ema1Current = data.ema1[data.ema1.length - 1];
            const ema1Previous = data.ema1[data.ema1.length - 2];
            const ema2Current = data.ema2[data.ema2.length - 1];
            const ema2Previous = data.ema2[data.ema2.length - 2];

            if (ema1Previous <= ema2Previous && ema1Current > ema2Current) {
                logAlert(`¡Alerta! Cruce hacia arriba en ${symbol} - Señal de LONG`);
                addPastCross(symbol, 'LONG');
            } else if (ema1Previous >= ema2Previous && ema1Current < ema2Current) {
                logAlert(`¡Alerta! Cruce hacia abajo en ${symbol} - Señal de SHORT`);
                addPastCross(symbol, 'SHORT');
            }

            checkUpcomingCross(symbol, ema1Current, ema2Current);
        }

        function logAlert(message) {
            const alertsContainer = document.getElementById('alertsContainer');
            alertsContainer.innerHTML = `<p>${new Date().toLocaleTimeString()}: ${message}</p>` + alertsContainer.innerHTML;
            sendNotification(message);
        }

        function sendNotification(message) {
            if (Notification.permission === "granted") {
                new Notification("Alerta de EMA", { body: message });
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        new Notification("Alerta de EMA", { body: message });
                    }
                });
            }
        }

        function checkUpcomingCross(symbol, ema1, ema2) {
            const difference = Math.abs(ema1 - ema2);
            const threshold = 0.001 * (ema1 + ema2) / 2;

            if (difference < threshold) {
                updateUpcomingCrosses(symbol, difference);
            }
        }

        function updateUpcomingCrosses(symbol, difference) {
            const container = document.getElementById('upcomingCrossesContainer');
            const crosses = Array.from(container.children);
            const existingIndex = crosses.findIndex(p => p.dataset.symbol === symbol);

            if (existingIndex !== -1) {
                container.removeChild(crosses[existingIndex]);
            }

            const newP = document.createElement('p');
            newP.textContent = `${symbol}: Diferencia de ${difference.toFixed(6)}`;
            newP.dataset.symbol = symbol;
            newP.dataset.difference = difference;

            let inserted = false;
            for (let i = 0; i < crosses.length; i++) {
                if (difference < parseFloat(crosses[i].dataset.difference)) {
                    container.insertBefore(newP, crosses[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                container.appendChild(newP);
            }

            while (container.children.length > 10) {
                container.removeChild(container.lastChild);
            }
        }

        function addPastCross(symbol, direction) {
            pastCrosses.unshift({ symbol, direction, time: new Date() });
            if (pastCrosses.length > 10) {
                pastCrosses.pop();
            }
            updatePastCrossesDisplay();
        }

        function updatePastCrossesDisplay() {
            const container = document.getElementById('pastCrossesContainer');
            container.innerHTML = '';
            pastCrosses.forEach(cross => {
                const p = document.createElement('p');
                p.textContent = `${cross.time.toLocaleTimeString()}: ${cross.symbol} - ${cross.direction}`;
                container.appendChild(p);
            });
        }

        function updateChart() {
            const symbol = document.getElementById('symbolSelect').value;
            const data = symbolsData[symbol];

            if (!data) return;

            if (chart) {
                chart.destroy();
            }

            const ctx = document.getElementById('chartContainer').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [...Array(data.prices.length).keys()],
                    datasets: [
                        {
                            label: 'Precio',
                            data: data.prices,
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1
                        },
                        {
                            label: `EMA ${ema1Period}`,
                            data: data.ema1,
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.1
                        },
                        {
                            label: `EMA ${ema2Period}`,
                            data: data.ema2,
                            borderColor: 'rgb(54, 162, 235)',
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    title: {
                        display: true,
                        text: symbol
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Tiempo'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Precio'
                            }
                        }
                    }
                }
            });
        }

        // Solicitar permiso para notificaciones al cargar la página
        if (Notification.permission !== "granted" && Notification.permission !== "denied") {
            Notification.requestPermission();
        }
    </script>
</body>
</html>
